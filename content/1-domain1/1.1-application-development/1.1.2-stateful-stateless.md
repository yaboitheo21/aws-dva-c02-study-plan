---
title: "1.1.2 Stateful vs Stateless"
date: 2025-02-11
weight: 2
---

## Stateful vs Stateless

![Stateful vs Stateless](/aws-dva-c02-study-plan/images/1-domain1/Stateful_vs_Stateless.png)

**Stateful** là hệ thống "giữ lại dữ liệu/ngữ cảnh của phiên làm việc (session) giữa các lần tương tác", còn **Stateless** là hệ thống "không bảo toàn dữ liệu giữa các phiên" và sẽ dựa vào thành phần bên ngoài (database/cache) để quản lý state khi cần.

AWS nhấn mạnh **stateless thường hợp với workload động và yêu cầu thay đổi nhanh**, vì dễ mở rộng ngang và triển khai linh hoạt hơn.

---

### Stateless

Mỗi request được xử lý **độc lập** và server không cần "nhớ" dữ liệu phiên trước đó, vì vậy việc nhân bản nhiều instance để scale ngang thường đơn giản.

**Lợi ích chính (theo AWS):**
- **Scalability** — dễ replicate/distribute
- **Reliability / Fault Tolerance** — thay thế/khởi động lại component không ảnh hưởng hệ thống
- **Cost-effectiveness** — on-demand scaling, phù hợp mô hình serverless

**Ví dụ:** Lambda functions, API Gateway, containers trên ECS/EKS

```text
Client -> LB -> [API/Service A] -> (DB/Cache chung nếu cần)
             -> [API/Service B] -> (DB/Cache chung nếu cần)
```

---

### Stateful

Dữ liệu session của client được **lưu lại qua nhiều lần request**, có thể giúp xử lý "nhanh" hơn trong vài tình huống vì server đã có sẵn context.

AWS chỉ ra stateful thường **phù hợp workload dự đoán được** và tạo trải nghiệm nhất quán, nhưng sẽ phát sinh bài toán **quản lý session khi scale** và khi có lỗi.

Trong thực tế (ví dụ game services), AWS mô tả có những job cần "persistent connect" (stateful), nhưng nhiều job khác có thể dùng REST API (stateless).

**Ví dụ:** WebSocket connections, session-based apps, game servers

```text
Client -> LB (sticky) -> Server 1 (giữ session)
Client -> LB (sticky) -> Server 2 (giữ session)
```

---

### Chuyển Stateful → Stateless

Hướng chung AWS khuyến nghị là **"externalize state"**: stateless system không tự giữ state giữa các phiên mà phụ thuộc database hoặc cache bên ngoài để quản lý state.

AWS nhấn mạnh "externalizing session data" sang các dịch vụ tối ưu cho truy cập tốc độ cao như **in-memory cache** có thể giảm latency so với việc giữ session data "bên trong" ứng dụng.

| Vấn đề | Giải pháp |
|---------|-----------|
| Session data | Đưa ra external store (ElastiCache Redis) để mọi instance dùng chung |
| User state | Lưu ở datastore chung (DynamoDB) để instance nào xử lý cũng đọc/ghi được |
| Upload files / static assets | Tách khỏi app server, lưu ở S3 |
| Sticky sessions | Dùng ELB sticky sessions (không khuyến khích — chỉ là giải pháp tạm) |

---

{{% notice tip %}}
**Exam Tip:**
- Đề nhấn mạnh "**handle traffic spike**", "**horizontal scaling**", "**resilience**" → AWS hướng bạn về **stateless design** vì dễ scale, tăng fault tolerance và tối ưu chi phí theo nhu cầu.
- Đề nhấn mạnh "**persistent connection**" hoặc workload kiểu realtime cần giữ kết nối liên tục → tín hiệu của **stateful component** (nhưng vẫn có thể tách phần còn lại sang stateless).
- Hỏi về **session management** → ElastiCache Redis hoặc DynamoDB.
{{% /notice %}}
