---
title: "4.3.10 Real-World Optimization Scenarios"
date: 2025-02-11
weight: 10
---

## Real-World Optimization Scenarios

### Scenario 1: Lambda Concurrency

**Question**: What service configure để add scaling to Lambda functions?

**Answer**: 
- **Reserved Concurrency** - Guarantee capacity, prevent throttling
- **Provisioned Concurrency** - Pre-warmed instances, eliminate cold starts
- **Burst** - Automatic scaling up to account limits

```yaml
Resources:
  MyFunction:
    Type: AWS::Lambda::Function
    Properties:
      ReservedConcurrentExecutions: 100  # Reserved
      
  MyProvisionedConfig:
    Type: AWS::Lambda::Alias
    Properties:
      ProvisionedConcurrencyConfig:
        ProvisionedConcurrentExecutions: 10  # Provisioned
```

### Scenario 2: DynamoDB Streams for Missing Data

**Problem**: Students book appointments với advisors. Lambda + EventBridge process data daily từ DynamoDB, results stored trong S3. Some new appointments trong DynamoDB **không được sent to S3**.

**Root cause**: EventBridge chỉ chạy daily, miss real-time changes.

**Solution**: Add **DynamoDB Streams**
- Captures **all data modifications** to table
- Real-time stream of changes
- Lambda triggered immediately on changes
- Ensures no data loss

```python
# Lambda triggered by DynamoDB Stream
def handler(event, context):
    for record in event['Records']:
        if record['eventName'] == 'INSERT':
            new_appointment = record['dynamodb']['NewImage']
            # Process and save to S3
            save_to_s3(new_appointment)
```

### Scenario 3: ECS + RDS Performance

**Problem**: Application hosted trong ECS cluster uses RDS database. Performance slows during requests với **same read queries**.

**Solutions**:
1. **Add RDS Read Replicas**
   - Offload read traffic
   - Scale read capacity
   - Reduce load on primary

2. **Add ElastiCache**
   - Cache frequent queries
   - Sub-millisecond latency
   - Reduce database load

```python
# ElastiCache pattern
import redis
cache = redis.Redis(host='cache-endpoint')

def get_data(key):
    # Try cache first
    cached = cache.get(key)
    if cached:
        return cached
    
    # Cache miss - query database
    data = db.query(key)
    cache.setex(key, 3600, data)  # Cache 1 hour
    return data
```

### Scenario 4: S3 + CloudFront Authentication

**Problem**: Application uses S3 behind CloudFront distribution. New requirements:
- Only allow **paying customers** access
- Low latency

**Solution**: **Lambda@Edge** + **Amazon Cognito**
- Cognito: Authentication and authorization
- Lambda@Edge: Verify tokens at edge locations
- CloudFront: Low latency content delivery

```python
# Lambda@Edge viewer request
def handler(event, context):
    request = event['Records'][0]['cf']['request']
    headers = request['headers']
    
    # Verify Cognito token
    token = headers.get('authorization', [{}])[0].get('value')
    if not verify_cognito_token(token):
        return {
            'status': '401',
            'statusDescription': 'Unauthorized'
        }
    
    return request
```

### Scenario 5: School Account Creation Workflow

**Problem**: Build workflow cho school allowing creation of new accounts online.

**Architecture**:
```text
Student Form → API Gateway → Step Functions
                              ↓
                         1. Validate Info (Lambda)
                              ↓
                         2. Check Existing (Lambda + DynamoDB)
                              ↓
                         3. Create Account (Lambda + DynamoDB)
                              ↓
                         4. Send Notification (Lambda + SQS/EventBridge)
```

**Services**:
- **API Gateway** - REST API endpoint
- **Step Functions** - Orchestrate workflow
- **Lambda** - Business logic (validate, check, create, notify)
- **DynamoDB** - Store student data
- **SQS/EventBridge** - Messaging
- **GitHub** - Code repository
- **X-Ray** - Review traces

**Workflow Steps**:
1. Student fills out form
2. Application validates information
3. Check if existing student exists
4. Backend creates new account
5. Student notified of successful completion

### Scenario 6: Direct Service Integrations

**Question**: How to implement direct service integrations?

**Answer**: Dive deeper into **Serverless Application Lens** of AWS Well-Architected Framework.

**Examples**:
- API Gateway → DynamoDB (no Lambda)
- API Gateway → SQS (no Lambda)
- API Gateway → Step Functions (no Lambda)
- EventBridge → Step Functions
- S3 → EventBridge → Lambda

**Benefits**:
- Reduce latency
- Lower cost (no Lambda invocations)
- Simpler architecture
- Less code to maintain

### Scenario 7: Process Large Data

**Question**: What AWS service process large amounts of data?

**Answer**: **Amazon EMR** (Elastic MapReduce)
- Managed Hadoop framework
- Process vast amounts of data
- Options for moving data to S3
- Spark, Hive, Presto support

**Use cases**:
- Big data processing
- Log analysis
- Machine learning
- ETL workloads

{{% notice tip %}}
**Exam Tips:**
- **Lambda concurrency**: Reserved (guarantee) vs Provisioned (pre-warm)
- **DynamoDB Streams**: Capture all modifications, real-time
- **RDS slow reads**: Read replicas or ElastiCache
- **CloudFront auth**: Lambda@Edge + Cognito
- **Workflow orchestration**: Step Functions
- **Direct integrations**: API Gateway → DynamoDB/SQS (no Lambda)
- **Big data**: Amazon EMR
{{% /notice %}}
